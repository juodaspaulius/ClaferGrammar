-- automatically generated by BNF Converter
module Main where


import System.IO ( stdin, hGetContents )
import System.Environment ( getArgs, getProgName )
import System.Exit ( exitFailure, exitSuccess )

import Control.Monad.State

import Data.Maybe
import Data.List.Split
import Data.Either

import Lexclafer
import Parclafer
import Skelclafer
import Printclafer
import Absclafer
import ClaferT
import LayoutResolver


import ErrM

type ParseFun a = [Token] -> Err a

myLLexer = myLexer

type Verbosity = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = if v > 1 then putStrLn s else return ()

run :: String -> IO ()
run input =
  do
    result <- runClaferT $ parse input
    result `cth` handleErrs
  where
  cth (Left err) f = f err
  cth (Right r)  _ = showTree 2 r
  handleErrs :: [ClaferErr] -> IO ()
  handleErrs = mapM_ handleErr
  handleErr (ClaferErr mesg) =
    do
      putStrLn "\nError...\n"
      putStrLn mesg
      exitFailure
  -- We only use one fragment. Fragment id and position is not useful to us. We
  -- only care about the position relative to
  handleErr (ParseErr ErrPos{modelPos = Pos l c} mesg) =
    do
      putStrLn $ "\nParse failed at line " ++ show l ++ " column " ++ show c ++ "..."
      putStrLn mesg
      exitFailure
  handleErr (SemanticErr ErrPos{modelPos = Pos l c} mesg) =
    do
      putStrLn $ "\nCompile error at line " ++ show l ++ " column " ++ show c ++ "..."
      putStrLn mesg
      exitFailure
  handleErr _ = error "Function handleErr from Main file was given an invalid argument"

showTree :: (Show a, Print a) => Int -> a -> IO ()
showTree v tree
 = do
      putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
      putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree

runFile :: FilePath -> IO ()
runFile f = putStrLn f >> readFile f >>= run

main :: IO ()
main = do args <- getArgs
          case args of
            [] -> hGetContents stdin >>= run
            fs -> mapM_ runFile fs

parse :: (Monad m) => String -> ClaferT m Module
parse s = do
    tokens <- resolveLayout $ myLexer s
    liftParseErr $ pModule tokens

  --  (>>= \x -> (-> return . pModule) x) . resolveLayout . myLexer
  --  (>>= (return . pModule)) . resolveLayout . myLexer

-- | Converts one Err. liftParseErrs is better if you want to report multiple errors.
-- | This method will only report one before ceasing execution.
liftParseErr :: Monad m => Err a -> ClaferT m a
liftParseErr e = head `liftM` liftParseErrs [e]

-- | Converts the Err monads (created by the BNFC parser generator) to ClaferT
liftParseErrs :: Monad m => [Err a] -> ClaferT m [a]
liftParseErrs e =
  do
    result <- zipWithM extract [0..] e
    case partitionEithers result of
      ([], ok) -> return ok
      (e',  _) -> throwErrs e'
  where
  extract _ (Ok m)  = return $ Right m
  extract frgId (Bad p s) =
    do
      -- Bad maps to ParseErr
      return $ Left $ ParseErr (ErrPos frgId p p) s


